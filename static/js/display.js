const gpuEdgeCanny=(e,t)=>(o,r,a=!0)=>{console.log("canny");let i,u,n,_="#version 300 es\n  \n    in vec2 a_vertex;\n    in vec2 a_texCoord;\n\n    uniform vec2 u_resolution;\n    \n    out vec2 v_texCoord;\n    \n    void main() {\n      v_texCoord = a_texCoord;\n      vec2 clipSpace = a_vertex * u_resolution * 2.0 - 1.0;\n      gl_Position = vec4(clipSpace * vec2(1,-1), 0.0, 1.0);\n    }\n  ",x="uint16"===o.type?"usampler2D":"sampler2D";switch(o.type){case"uint8":u="1.0 / float(textureSize(u_image,0).y)",n="(vec4(0.0) + texture(u_image, vec2(v_texCoord.x, v_texCoord.y - stepSizeH * 2.0 )) * u_kernel[0] + texture(u_image, vec2(v_texCoord.x, v_texCoord.y - stepSizeH)) * u_kernel[1] + texture(u_image, vec2(v_texCoord.x, v_texCoord.y )) * u_kernel[2] + texture(u_image, vec2(v_texCoord.x, v_texCoord.y + stepSizeH )) * u_kernel[3] + texture(u_image, vec2(v_texCoord.x, v_texCoord.y + stepSizeH * 2.0)) * u_kernel[4])";break;case"rgba":i="texture(u_image, v_texCoord).rgb";break;case"uint16":u="1.0 / float(textureSize(u_image,0).y)",n="(vec4(0.0) + float(texture(u_image, vec2(v_texCoord.x, v_texCoord.y - stepSizeH * 2.0 )).r) * u_kernel[0] + float(texture(u_image, vec2(v_texCoord.x, v_texCoord.y - stepSizeH)).r) * u_kernel[1] + float(texture(u_image, vec2(v_texCoord.x, v_texCoord.y )).r) * u_kernel[2] + float(texture(u_image, vec2(v_texCoord.x, v_texCoord.y + stepSizeH )).r) * u_kernel[3] + float(texture(u_image, vec2(v_texCoord.x, v_texCoord.y + stepSizeH * 2.0)).r) * u_kernel[4])/maxUint16";break;case"float32":u="1.0 / float(textureSize(u_image,0).y)",n="(vec4(0.0) + texture(u_image, vec2(v_texCoord.x, v_texCoord.y - stepSizeH * 2.0 )).r * u_kernel[0] + texture(u_image, vec2(v_texCoord.x, v_texCoord.y - stepSizeH)).r * u_kernel[1] + texture(u_image, vec2(v_texCoord.x, v_texCoord.y )).r * u_kernel[2] + texture(u_image, vec2(v_texCoord.x, v_texCoord.y + stepSizeH )).r * u_kernel[3] + texture(u_image, vec2(v_texCoord.x, v_texCoord.y + stepSizeH * 2.0)).r * u_kernel[4])"}let v,s,l,d=gpu.createProgram(r,_,((e,t,o,r)=>`#version 300 es\n    #pragma debug(on)\n\n    precision mediump usampler2D;\n    precision mediump float;\n    \n    in vec2 v_texCoord;\n    const float maxUint16 = 65535.0;\n    uniform ${e} u_image;\n    uniform float u_kernel[5];\n    \n    out vec4 outColor;\n    \n    void main() {\t\n    \tfloat stepSizeH = float(${o});\t\n\t\toutColor = vec4(${r});\n\t\t\n\t\toutColor.a=1.0;\n    }`)(x,0,u,n)),g=gpu.createGPU(r,o.width,o.height).size(o.width,o.height).geometry(gpu.rectangle(o.width,o.height)).attribute("a_vertex",2,"float",16,0).attribute("a_texCoord",2,"float",16,8).redirectTo("fbo01","float32",0).texture(o).packWith(d).clearCanvas([0,1,1,1]).preprocess().uniform("u_resolution",new Float32Array([1/o.width,1/o.height])).uniform("u_image",0).uniform("u_kernel",new Float32Array([.0625,.25,.375,.25,.0625])).run();switch(console.log("horizontal blur done..."),o.type){case"uint8":s="1.0 / float(textureSize(u_image,0).x)",l="(vec4(0.0) + texture(u_image, vec2(v_texCoord.x - stepSizeV * 2.0 , v_texCoord.y)) * u_kernel[0] + texture(u_image, vec2(v_texCoord.x - stepSizeV, v_texCoord.y)) * u_kernel[1] + texture(u_image, vec2(v_texCoord.x, v_texCoord.y )) * u_kernel[2] + texture(u_image, vec2(v_texCoord.x + stepSizeV, v_texCoord.y )) * u_kernel[3] + texture(u_image, vec2(v_texCoord.x + stepSizeV * 2.0, v_texCoord.y)) * u_kernel[4])";break;case"rgba":v="texture(u_image, v_texCoord).rgb";break;case"uint16":s="1.0 / float(textureSize(u_image,0).x)",l="(vec4(0.0) + float(texture(u_image, vec2(v_texCoord.x - stepSizeV * 2.0 , v_texCoord.y)).r) * u_kernel[0] + float(texture(u_image, vec2(v_texCoord.x - stepSizeV, v_texCoord.y)).r) * u_kernel[1] + float(texture(u_image, vec2(v_texCoord.x, v_texCoord.y )).r) * u_kernel[2] + float(texture(u_image, vec2(v_texCoord.x + stepSizeV, v_texCoord.y )).r) * u_kernel[3] + float(texture(u_image, vec2(v_texCoord.x + stepSizeV * 2.0, v_texCoord.y)).r) * u_kernel[4])/maxUint16";break;case"float32":s="1.0 / float(textureSize(u_image,0).x)",l="(vec4(0.0) + texture(u_image, vec2(v_texCoord.x - stepSizeV * 2.0 , v_texCoord.y)).r * u_kernel[0] + texture(u_image, vec2(v_texCoord.x - stepSizeV, v_texCoord.y)).r * u_kernel[1] + texture(u_image, vec2(v_texCoord.x, v_texCoord.y )).r * u_kernel[2] + texture(u_image, vec2(v_texCoord.x + stepSizeV, v_texCoord.y )).r * u_kernel[3] + texture(u_image, vec2(v_texCoord.x + stepSizeV * 2.0, v_texCoord.y)).r * u_kernel[4])"}let c,m,p,C,f,S,z,h,b,k,y,X,w=gpu.createProgram(r,_,((e,t,o,r)=>`#version 300 es\n    #pragma debug(on)\n\n    precision mediump usampler2D;\n    precision mediump float;\n    \n    in vec2 v_texCoord;\n    const float maxUint16 = 65535.0;\n    uniform ${e} u_image;\n    uniform float u_kernel[5];\n    \n    out vec4 outColor;\n    \n    void main() {\t\n    \tfloat stepSizeV = float(${o});\t\n\t\toutColor = vec4(${r});\n\t\t\n\t\toutColor.a=1.0;\n    }`)(x,0,s,l)),Y=gpu.createGPU(r).size(o.width,o.height).geometry(gpu.rectangle(o.width,o.height)).attribute("a_vertex",2,"float",16,0).attribute("a_texCoord",2,"float",16,8).texture(g.framebuffers.fbo01).redirectTo("fbo02","float32",0).packWith(w).clearCanvas([0,1,1,1]).preprocess().uniform("u_resolution",new Float32Array([1/o.width,1/o.height])).uniform("u_image",0).uniform("u_kernel",new Float32Array([.0625,.25,.375,.25,.0625])).run();switch(console.log("vertical blur done..."),o.type){case"uint8":m="1.0 / float(textureSize(u_image,0).x)",p="1.0 / float(textureSize(u_image,0).y)",C="texture(u_image, v_texCoord - vec2(stepSizeX,stepSizeY)).r",f="texture(u_image, vec2(v_texCoord.s, v_texCoord.t - stepSizeY)).r",S="texture(u_image, vec2(v_texCoord.s + stepSizeX, v_texCoord.t - stepSizeY)).r",z="texture(u_image, vec2(v_texCoord.s - stepSizeX, v_texCoord.t)).r",h="texture(u_image, v_texCoord).r",b="texture(u_image, vec2(v_texCoord.s + stepSizeX, v_texCoord.t)).r",k="texture(u_image, vec2(v_texCoord.s - stepSizeX, v_texCoord.t + stepSizeY)).r",y="texture(u_image, vec2(v_texCoord.s, v_texCoord.t + stepSizeX)).r",X="texture(u_image, v_texCoord + vec2(stepSizeX,stepSizeY)).r";break;case"rgba":c="texture(u_image, v_texCoord).rgb";break;case"uint16":m="1.0 / float(textureSize(u_image,0).x)",p="1.0 / float(textureSize(u_image,0).y)",C="float(texture(u_image, v_texCoord - vec2(stepSizeX,stepSizeY)).r)",f="float(texture(u_image, vec2(v_texCoord.s, v_texCoord.t - stepSizeY)).r)",S="float(texture(u_image, vec2(v_texCoord.s + stepSizeX, v_texCoord.t - stepSizeY)).r)",z="float(texture(u_image, vec2(v_texCoord.s - stepSizeX, v_texCoord.t)).r)",h="float(texture(u_image, v_texCoord).r)",b="float(texture(u_image, vec2(v_texCoord.s + stepSizeX, v_texCoord.t)).r)",k="float(texture(u_image, vec2(v_texCoord.s - stepSizeX, v_texCoord.t + stepSizeY)).r)",y="float(texture(u_image, vec2(v_texCoord.s, v_texCoord.t + stepSizeX)).r)",X="float(texture(u_image, v_texCoord + vec2(stepSizeX,stepSizeY)).r)";break;case"float32":m="1.0 / float(textureSize(u_image,0).x)",p="1.0 / float(textureSize(u_image,0).y)",C="texture(u_image, v_texCoord - vec2(stepSizeX,stepSizeY)).r",f="texture(u_image, vec2(v_texCoord.s, v_texCoord.t - stepSizeY)).r",S="texture(u_image, vec2(v_texCoord.s + stepSizeX, v_texCoord.t - stepSizeY)).r",z="texture(u_image, vec2(v_texCoord.s - stepSizeX, v_texCoord.t)).r",h="texture(u_image, v_texCoord).r",b="texture(u_image, vec2(v_texCoord.s + stepSizeX, v_texCoord.t)).r",k="texture(u_image, vec2(v_texCoord.s - stepSizeX, v_texCoord.t + stepSizeY)).r",y="texture(u_image, vec2(v_texCoord.s, v_texCoord.t + stepSizeX)).r",X="texture(u_image, v_texCoord + vec2(stepSizeX,stepSizeY)).r"}let $,H,V,D=gpu.createProgram(r,_,((e,t,o,r,a,i,u,n,_,x,v,s,l)=>`#version 300 es\n    #pragma debug(on)\n\n    precision mediump usampler2D;\n    precision mediump float;\n    \n    in vec2 v_texCoord;\n    const float maxUint16 = 65535.0;\n    uniform ${e} u_image;\n    const mat2 ROTATION_MATRIX = mat2(0.92388, 0.38268, -0.38268, 0.92388); // 1/16 turn rotation matrix\n    uniform float u_kernel_H[9]; //wrong kernels (not flipped) in original version !! hahahahaha I am the best :)\n    uniform float u_kernel_V[9];\n    \n    out vec4 outColor;\n    \n    void main() {\t\n    \tfloat stepSizeX = float(${o});\n    \tfloat stepSizeY = float(${r});\n    \t//get the 9 neighboring pixel intensities\n    \tfloat a11 = float(${a});\t\n    \tfloat a12 = float(${i});\n    \tfloat a13 = float(${u});\n    \tfloat a21 = float(${n});\n    \tfloat a22 = float(${_});\n    \tfloat a23 = float(${x});\n    \tfloat a31 = float(${v});\n    \tfloat a32 = float(${s});\n    \tfloat a33 = float(${l});\n    \t\n\t\t//gradient vector\n\t\tvec2 sobel = vec2 (u_kernel_H[0] * a11 + u_kernel_H[1] * a12 + u_kernel_H[2] * a13 + u_kernel_H[3] * a21 + u_kernel_H[4] * a22 + u_kernel_H[5] * a23 + u_kernel_H[6] * a31 + u_kernel_H[7] * a32 + u_kernel_H[8] * a33, u_kernel_V[0] * a11 + u_kernel_V[1] * a12 + u_kernel_V[2] * a13 + u_kernel_V[3] * a21 + u_kernel_V[4] * a22 + u_kernel_V[5] * a23 + u_kernel_V[6] * a31 + u_kernel_V[7] * a32 + u_kernel_V[8] * a33);\n\n\t\tvec2 rotatedSobel = ROTATION_MATRIX * sobel;\n\t\tvec2 quadrantSobel = vec2(rotatedSobel.x * rotatedSobel.x - rotatedSobel.y * rotatedSobel.y, 2.0 * rotatedSobel.x * rotatedSobel.y);\n\t\t\n\t\t//gradient direction\n\t\tvec2 neighDir = vec2(step(-1.5, sign(quadrantSobel.x) + sign(quadrantSobel.y)), step(0.0, - quadrantSobel.x) - step(0.0, quadrantSobel.x) * step(0.0, - quadrantSobel.y));\n\t\t\n\t\toutColor.r = sqrt(sobel.x*sobel.x + sobel.y*sobel.y); //gradient magnitude\n\t\toutColor.gb = neighDir * 0.5 + vec2(0.5); // gradient direction\n\t\toutColor.a = 0.0; \n    }`)(x,0,m,p,C,f,S,z,h,b,k,y,X)),A=gpu.createGPU(r,o.width,o.height).size(o.width,o.height).geometry(gpu.rectangle(o.width,o.height)).attribute("a_vertex",2,"float",16,0).attribute("a_texCoord",2,"float",16,8).texture(Y.framebuffers.fbo02).redirectTo("fbo1","float32",0).packWith(D).clearCanvas([0,1,1,1]).preprocess().uniform("u_resolution",new Float32Array([1/o.width,1/o.height])).uniform("u_image",0).uniform("u_kernel_H",new Float32Array([1,0,-1,2,0,-2,1,0,-1])).uniform("u_kernel_V",new Float32Array([-1,-2,-1,0,0,0,1,2,1])).run();switch(console.log("sobel filter done..."),o.type){case"uint8":$="texture(u_image, v_texCoord)",H="texture(u_image, v_texCoord + (neighDir * vec2(stepSizeX,stepSizeY)))",V="texture(u_image, v_texCoord - (neighDir * vec2(stepSizeX,stepSizeY)))";break;case"rgba":v="texture(u_image, v_texCoord).rgb";break;case"uint16":$="vec4(float(texture(u_image, v_texCoord)))",H="vec4(float(texture(u_image, v_texCoord + (neighDir * vec2(stepSizeX,stepSizeY)))))",V="vec4(float(texture(u_image, v_texCoord - (neighDir * vec2(stepSizeX,stepSizeY)))))";break;case"float32":$="texture(u_image, v_texCoord)",H="texture(u_image, v_texCoord + (neighDir * vec2(stepSizeX,stepSizeY)))",V="texture(u_image, v_texCoord - (neighDir * vec2(stepSizeX,stepSizeY)))"}let P,U,F,T,q,G,I,W,O,R,M=gpu.createProgram(r,_,((e,t,o,r,a,i,u)=>`#version 300 es\n    #pragma debug(on)\n\n    precision mediump usampler2D;\n    precision mediump float;\n    \n    in vec2 v_texCoord;\n    const float maxUint16 = 65535.0;\n    uniform ${e} u_image;\n    uniform vec2 threshold;\n    \n    out vec4 outColor;\n    \n    void main() {\n    \n    \tfloat stepSizeX = float(${o});\n    \tfloat stepSizeY = float(${r});\n\t\tvec4 texCoord = vec4(${a});\n\t\tvec2 neighDir = texCoord.gb * 2.0 - vec2(1.0);\n\t\tvec4 n1 = vec4(${i}); //grad of neighboring pixel in grad direction\n\t\tvec4 n2 = vec4(${u}); //grad of opposite neighboring pixel in grad direction\n\t\t\n\t\tfloat edgeStrength = texCoord.r * step(max(n1.r,n2.r), texCoord.r); // step returns 0 if grad is not a maximum , returns 1 if grad is a maximum, then multiplied by grad of the current pixel\n\t\toutColor = vec4(smoothstep(threshold.s, threshold.t, edgeStrength),0.0,0.0,1.0); //returns a value between 0 and 1 if grad is between low thr and high thr\n\t\t\n    }`)(x,0,m,p,$,H,V)),N=gpu.createGPU(r,o.width,o.height).size(o.width,o.height).geometry(gpu.rectangle(o.width,o.height)).attribute("a_vertex",2,"float",16,0).attribute("a_texCoord",2,"float",16,8).texture(A.framebuffers.fbo1).redirectTo("fbo2","float32",0).packWith(M).clearCanvas([0,1,1,1]).preprocess().uniform("u_resolution",new Float32Array([1/o.width,1/o.height])).uniform("u_image",0).uniform("threshold",new Float32Array([e/255,t/255])).run();switch(console.log("non maximum suppression done..."),o.type){case"uint8":U="texture(u_image, v_texCoord).r",F="texture(u_image, v_texCoord - vec2(stepSizeX,stepSizeY)).r",T="texture(u_image, vec2(v_texCoord.s, v_texCoord.t - stepSizeY)).r",q="texture(u_image, vec2(v_texCoord.s + stepSizeX, v_texCoord.t - stepSizeY)).r",G="texture(u_image, vec2(v_texCoord.s - stepSizeX, v_texCoord.t)).r",I="texture(u_image, vec2(v_texCoord.s + stepSizeX, v_texCoord.t)).r",W="texture(u_image, vec2(v_texCoord.s - stepSizeX, v_texCoord.t + stepSizeY)).r",O="texture(u_image, vec2(v_texCoord.s, v_texCoord.t + stepSizeX)).r",R="texture(u_image, v_texCoord + vec2(stepSizeX,stepSizeY)).r";break;case"rgba":P="texture(u_image, v_texCoord).rgb";break;case"uint16":U="float(texture(u_image, v_texCoord).r)",F="float(texture(u_image, v_texCoord - vec2(stepSizeX,stepSizeY)).r)",T="float(texture(u_image, vec2(v_texCoord.s, v_texCoord.t - stepSizeY)).r)",q="float(texture(u_image, vec2(v_texCoord.s + stepSizeX, v_texCoord.t - stepSizeY)).r)",G="float(texture(u_image, vec2(v_texCoord.s - stepSizeX, v_texCoord.t)).r)",I="float(texture(u_image, vec2(v_texCoord.s + stepSizeX, v_texCoord.t)).r)",W="float(texture(u_image, vec2(v_texCoord.s - stepSizeX, v_texCoord.t + stepSizeY)).r)",O="float(texture(u_image, vec2(v_texCoord.s, v_texCoord.t + stepSizeX)).r)",R="float(texture(u_image, v_texCoord + vec2(stepSizeX,stepSizeY)).r)";break;case"float32":U="texture(u_image, v_texCoord).r",F="texture(u_image, v_texCoord - vec2(stepSizeX,stepSizeY)).r",T="texture(u_image, vec2(v_texCoord.s, v_texCoord.t - stepSizeY)).r",q="texture(u_image, vec2(v_texCoord.s + stepSizeX, v_texCoord.t - stepSizeY)).r",G="texture(u_image, vec2(v_texCoord.s - stepSizeX, v_texCoord.t)).r",I="texture(u_image, vec2(v_texCoord.s + stepSizeX, v_texCoord.t)).r",W="texture(u_image, vec2(v_texCoord.s - stepSizeX, v_texCoord.t + stepSizeY)).r",O="texture(u_image, vec2(v_texCoord.s, v_texCoord.t + stepSizeX)).r",R="texture(u_image, v_texCoord + vec2(stepSizeX,stepSizeY)).r"}let E=gpu.createProgram(r,_,((e,t,o,r,a,i,u,n,_,x,v,s,l)=>`#version 300 es\n    #pragma debug(on)\n\n    precision mediump usampler2D;\n    precision mediump float;\n    \n    in vec2 v_texCoord;\n    const float maxUint16 = 65535.0;\n    uniform ${e} u_image;\n    \n    out vec4 outColor;\n    \n    void main() {\t\n    \tfloat stepSizeX = float(${o});\n    \tfloat stepSizeY = float(${r});\n    \tfloat edgeStrength = float(${a});\n    \t//get the 8 neighboring pixels' edge strength\n    \tfloat a11 = float(${i});\t\n    \tfloat a12 = float(${u});\n    \tfloat a13 = float(${n});\n    \tfloat a21 = float(${_});\n    \tfloat a23 = float(${x});\n    \tfloat a31 = float(${v});\n    \tfloat a32 = float(${s});\n    \tfloat a33 = float(${l});\n    \t\n\t\tfloat strongPixel = step(2.0, edgeStrength + a11 + a12 + a13 + a21 + a23 + a31 + a32 + a33); //accept weak pixel if the sum of edge strength is > 2.0\n\t\tfloat px = strongPixel + (edgeStrength - strongPixel) * step(0.49, abs(edgeStrength - 0.5)); // 1 if edge, 0 if not edge\n\t\toutColor = vec4(px,px,px,1.0); // white if edge, black if not edge\n    }`)(x,0,m,p,U,F,T,q,G,I,W,O,R));console.log("hysteresis done...");gpu.createGPU(r,o.width,o.height).size(o.width,o.height).geometry(gpu.rectangle(o.width,o.height)).attribute("a_vertex",2,"float",16,0).attribute("a_texCoord",2,"float",16,8).texture(N.framebuffers.fbo2).packWith(E).clearCanvas([0,1,1,1]).preprocess().uniform("u_resolution",new Float32Array([1/o.width,1/o.height])).uniform("u_image",0).run();return o};